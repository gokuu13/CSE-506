__author__ = "Gokul Kumar Manickavasagam"
__version__ = "0.1.0"

import csv
import time
import subprocess
import math
import re
import random


def readDestFromFile():
    """
    This function is used to read from NYC_Destinations.txt.
    The file contains destinations in NYC along with their latitude and longitudinal information.

    Args: None
    Returns: List of Destinations 
    """
    destinations = []
    with open('Destinations.txt', 'r') as file:
        reader = csv.reader(file, delimiter='\t')
        for index, row in enumerate(reader):
            if len(row) == 0:   # \r added by windows gives weird parsing issues
                continue
            if index > 9:
                break
            destinations.append(row)
        
        # Prints destinations and the cost associated
        for index, destination in enumerate(destinations):
            print(f"{index + 1}. {destination[0]} - ${destination[3]}")

    return destinations
    
def takeUserInputs():
    """
    This function is used to take input from the user
        trip_time - total time available for user to spend in NYC
        trip_cost - total user budget
        mandatory_dest - list of numbers corresponding to the destinations that the user wants to 100% visit

    Args: None
    Returns: trip_time, trip_cost, mandatory_dest, start_point, end_point 
    """
    trip_time = input("Enter time available for trip in hours: ")
    trip_cost = input("Enter Trip Budget: ")
    start_point = input("Enter Start Point (number): ")
    end_point = input("Enter Ending Point (number): ")
    mandatory_dest = input("Pick destinations you definitely want to visit (Give a comma separated list of numbers)\n")
    if mandatory_dest == '':
        man_dest_list = []
    else:
        man_dest_list = mandatory_dest.split(",")
    mandatory_dest_final = ""
    for man_dest in man_dest_list:
        if int(man_dest) != int(start_point) and int(man_dest) != int(end_point):
            mandatory_dest_final += man_dest + ","
    
    man_dest = mandatory_dest_final[:-1]
    return trip_time, trip_cost, man_dest, start_point, end_point

def runClingoApp(filename):
    """
    This function runs the clingo file with the appropriate conditions.
    Records the time taken by the program

    Args: filename (str) - name of the clingo file
    Returns: parsedOutput - parsed output of the clingo process
             stderr - error/warning messages generated by the clingo process
    """
    with open(filename, 'r') as file1, open('itinerary.lp', 'r') as file2, open('main.lp', 'w') as file3:
        userData = file1.read()
        code = file2.read()
        file3.write(userData + "\n" + code)

    command = "C:\\Users\\gokul\\Downloads\\clingo-5.3.0-win64\\clingo-5.3.0-win64\\clingo.exe main.lp"
    start_time = time.time()
    process = subprocess.run(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    end_time = time.time()
    # print(process.stdout.decode())
    print("Time Taken to Run Program: " + str(end_time - start_time))
    return process.stdout.decode(), process.stderr.decode()

def parseOutput(outputStr, destinations, start_point, end_point):
    """
    This function parses the clingo output and returns optimal paths as a list of strings

    Args: outputStr (str) - clingo output
    Returns: parsedOutput - parsed clingo output with 0 or more solutions
    """
    outputLines = outputStr.split("\n")
    if "UNSATISFIABLE" in outputLines[3]:
        print("We could not find an itinerary with your constraints.")
        return -1
    solutions = []
    solution = ""
    for i in range(4, len(outputLines)):
        if "Answer" in outputLines[i]:
            continue
        elif "Optimization" in outputLines[i]:
            solutions.append(solution)
            solution = ""
        elif "OPTIMUM" in outputLines[i]:
            break
        else:
            solution += outputLines[i] + "\n"
    
    solution_split = solutions[-1].split("numDest")

    pattern = r'"([^"]+)"' 
    edge_map = {}
    destinations = re.findall(pattern, solution_split[0])
    for i in range (0, len(destinations) - 1, 2):
        edge_map[destinations[i]] = destinations[i + 1]
    
    i = 2
    curr_dest = start_point
    print("Destination 1: " + start_point)
    while len(edge_map) > 0:
        next_dest = edge_map[curr_dest]
        print("Destination " + str(i) + ": " + next_dest)
        edge_map.pop(curr_dest)
        curr_dest = next_dest
        i += 1
    print("Total Time spent in Minutes = " + str(int(solution_split[1].split()[2][5:-1])))
    print("Total Money spend in USD = " + str(int(solution_split[1].split()[1][6:-1])))
    return 1

def haversine(lat1, lon1, lat2, lon2):
    """
    Calculate the great-circle distance between two points using the Haversine formula.
    :param lat1: Latitude of point 1 (in degrees)
    :param lon1: Longitude of point 1 (in degrees)
    :param lat2: Latitude of point 2 (in degrees)
    :param lon2: Longitude of point 2 (in degrees)
    :return: Distance in miles
    """
    R = 3959  # Earth's radius in miles
    lat1_rad = math.radians(lat1)
    lon1_rad = math.radians(lon1)
    lat2_rad = math.radians(lat2)
    lon2_rad = math.radians(lon2)

    dlon = lon2_rad - lon1_rad
    dlat = lat2_rad - lat1_rad

    a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    distance = R * c
    return distance

def createKnowledgeBase(trip_time, trip_cost, mandatory_dest, destinations, start_point, end_point):
    """
    This function creates the clingo knowledge base by creating a temporary .lp file with the user constraints and various destinations.

    Args: trip_time , trip_cost, mandatory_dest - user provided inputs
          destinations - all destinations curated
    Returns: filepath - location of the new file created
    """
    textToWrite = ""
    n = len(destinations)
    for i in range(n):
        textToWrite += "node(\"{}\", {}) .".format(destinations[i][0], destinations[i][3]) + "\n"
    maxDist = 0
    edgeSet = []
    for i in range(n):
        for j in range(n):
            if i != j:
                dist = haversine(float(destinations[i][1]), float(destinations[i][2]), 
                        float(destinations[j][1]), float(destinations[j][2]))
                maxDist = max(maxDist, dist)
                edgeSet.append([destinations[i][0], destinations[j][0], dist])

    textToWrite += "edge(\"Stony Brook\", \"Grand Central Terminal\", 90).\n"
    for edge in edgeSet:
        time = int(100 * edge[2] / maxDist)
        textToWrite += "edge(\"{}\", \"{}\", {}) .".format(edge[0], edge[1], time) + "\n"

    start = destinations[int(start_point) - 1][0]
    end = destinations[int(end_point) - 1][0]
    textToWrite += "start(\"{}\") .\n".format(start)
    textToWrite += "end(\"{}\") .\n".format(end)

    if mandatory_dest == '':
        mandatory_dest_list = []
    else:
        mandatory_dest_list = mandatory_dest.split(",")

    for dest in mandatory_dest_list:
        textToWrite += ":- not selected(_, \"{}\") .".format(destinations[int(dest) - 1][0]) + "\n"
    
    textToWrite += ":- cost(C), C > {} .\n".format(int(trip_time) * 60)
    textToWrite += ":- money(M), M > {} .\n".format(int(trip_cost))

    with open('userInput.lp', 'w', encoding='UTF8') as file1:
        file1.write(textToWrite)
    return 'userInput.lp'
            
def main():
    """
    This is the entry point of the program and calls all other functions. 
    It essentially calls functions to take input from the user, edit the clingo knowledge base,
    generate the various tour paths and 
    Args: none
    Returns: none
    """
    print("NYC Itinerary Planner")
    destinations = readDestFromFile()
    trip_time, trip_cost, mandatory_dest, start_point, end_point = takeUserInputs()
    filename = createKnowledgeBase(trip_time, trip_cost, mandatory_dest, destinations, start_point, end_point)
    output, stderr = runClingoApp(filename)
    # print(output)
    print(stderr)
    parseOutput(output, destinations, destinations[int(start_point) - 1][0], end_point)

if __name__ == "__main__":
    main()